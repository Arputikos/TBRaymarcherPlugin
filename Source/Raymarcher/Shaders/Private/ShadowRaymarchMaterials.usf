// Copyright 2021 Tomas Bartipan and Technical University of Munich.
// Licensed under MIT license - See License.txt for details.
// Special credits go to : Temaran (compute shader tutorial), TheHugeManatee (original concept, supervision) and Ryan Brucks
// (original raymarching code).

// This file contains functions that can be used for visualizing shadow volumes. 
// Mostly useful for debugging illumination shaders.

// Beware, modifications to this file will not be detected by the material shaders and they will not
// be recompiled. Shaders using this file have to be recompiled manually! (unless I find a way
// to tell the shadercompiler to always recompile the raymarch shaders on startup)

#pragma once
#include "RaymarchMaterialCommon.usf"



// Performs lit raymarch for the current pixel. The lighting information is taken from a precomputed light volume.
float4 PerformShadowRaymarch(
                              Texture3D LightVolume, // Light Volume  
                              float3 CurPos, float Thickness, // CurPos = Entry Position, Thickness is thickness of cube along the ray. Both in UVW space.
                              float StepCount, // How many steps we should take. Actual number of steps taken is StepCount * Thickness.
                              float3 ClippingCenter, float3 ClippingDirection, // Clipping plane position and direction of clipped away region
                              FMaterialPixelParameters MaterialParameters) // Material Parameters provided by UE.
{
    // StepSize in UVW is inverse to StepCount.
    float StepSize = 1 / StepCount;
    // Actual number of steps to take to march through the full thickness of the cube at the ray position.
    float FloatActualSteps = StepCount * Thickness;
    // Number of full steps to take.
    int MaxSteps = floor(FloatActualSteps);
    // Size of the last (not a full-sized) step.
    float FinalStep = frac(FloatActualSteps);
    
    // Get camera vector in local space and multiply it by step size.
    float3 LocalCamVec = -normalize(mul(MaterialParameters.CameraVector, GetPrimitiveData(MaterialParameters.PrimitiveId).WorldToLocal)) * StepSize;
    // Get step size in world units to be consistent with compute shaders' opacity calculations.
    float StepSizeWorld = length(mul(LocalCamVec, GetPrimitiveData(MaterialParameters.PrimitiveId).LocalToWorld));
    // Initialize accumulated light energy.
    float4 LightEnergy = float4(0.0, 0.0, 0.0, 0.0);
    // Jitter Entry position to avoid artifacts.
    JitterEntryPos(CurPos, LocalCamVec, MaterialParameters);
   
    float ReadVal = 0;
    
    int i = 0;
    for (i = 0; i < MaxSteps; i++)
    {
        CurPos += LocalCamVec; // Because we jitter only "against" the direction of LocalCamVec, start marching before first sample.
	    // Any position that is clipped by the clipping plane shall be ignored.
        if (!IsCurPosClipped(CurPos, ClippingCenter, ClippingDirection))
        {
            // Sample the illumination volume.
            ReadVal = 1 - LightVolume.SampleLevel(Material.Clamp_WorldGroupSettings, CurPos, 0);
            ReadVal = 1.0 - pow(1.0 - ReadVal, StepSize);
            AccumulateLightEnergy(LightEnergy, float4(1.0, 0.0, 0.0, ReadVal));
            
            // Exit early if light energy (opacity) is already very high (so future steps would have almost no impact on color).
            if (LightEnergy.a > 0.95f)
            {
                LightEnergy.a = 1.0f;
                break;
            };
        }
    }

    // Handle FinalStep (only if we went through all the previous steps and the final step size is above zero)
    if (i == MaxSteps && FinalStep > 0.0f)
    {
        CurPos += LocalCamVec * (FinalStep);
        // If the final step is clipped, don't do anything.
        if (!IsCurPosClipped(CurPos, ClippingCenter, ClippingDirection))
        {
                   // Sample the illumination volume.
            ReadVal = 1 - LightVolume.SampleLevel(Material.Clamp_WorldGroupSettings, CurPos, 0);
            ReadVal = 1.0 - pow(1.0 - ReadVal, StepSize);
            AccumulateLightEnergy(LightEnergy, float4(1.0, 0.0, 0.0, ReadVal));
        }
    }

    return LightEnergy;
}